==============================================================================================================
========================================Grading Information===================================================
==============================================================================================================
/*
On a Scale of 0 – 5, Grade each answer by comparing it to the solution below AND provide feedback. 
Include the grade and feedback/understanding of the answer query using SQL comments.
NOTE: Alternative methods of querying, if successfully fulfills the business request, are accepted as fully correct 

	Example 1:
	5/5 The given answer fully matching the solution method, 
	successfully answers the given business question by utilizing the correct tables PAINT, BICYCLE, and CUSTOMER
	and checking for the list of criterion against the joined tables.

	Example 2: 
	5/5 The given answer though not fully matching the solution method, 
	successfully answers the given business question by utilizing the correct tables PAINT, BICYCLE, and CUSTOMER
	in subqueries instead of JOINS.

	Example 3:
	4.8/5 The given answer mostly matches the solution method.
	It correctly joined tables PAINT, BICYCLE, and CUSTOMER 
	and have mostly correct conditions, but did not use pattern search like '%red%' 
	therefore causing the output to miss any bikes that's partially red.


============Example grading rubric:============
--Score of 0: The query does not execute in SQL, results in error message, or is missing. 
--Score of 0.1 to 4.9: The query executes, has some correct elements, but are not fully correct.
	--0.1: executable query, but not relevant or correct in answering the given question
	--......
	--4.9: nearly fully correct, but missing or has incorrect small elements, such as should be like '%red%' but used = 'red'.
--Score of 5: The query is fully correct in answering the business question and executes without issue.
*/




==============================================================================================================
========================================Solution Queries======================================================
==============================================================================================================
/*1. List the customers from California who bought red mountain bikes in September 2003. */
/* Use order date as date bought.*/
--5/5 no errors in execution and answers all business queries correctly
SELECT	Customer.CustomerID, Customer.LastName, Customer.FirstName, Bicycle.ModelType, Paint.ColorList, Bicycle.OrderDate, Bicycle.SaleState
FROM	Paint INNER JOIN (Customer INNER JOIN Bicycle ON Customer.CustomerID = Bicycle.CustomerID) ON Paint.PaintID = Bicycle.PaintID
WHERE	Bicycle.ModelType Like 'Mountain%' AND 
		Paint.ColorList Like '%Red%' AND 
		Month(Bicycle.OrderDate) = 9 AND
		Year(Bicycle.OrderDate) = 2003 AND 
		Bicycle.SaleState= 'CA'
ORDER BY Customer.LastName, Customer.FirstName;



/*2. List the employees who sold race bikes shipped to Wisconsin without the help of a retail store in 2001*/
--5/5 no errors in execution and answers all business queries correctly, uses is null instead of naming specific store id, distinct is unecessary
SELECT	DISTINCT Employee.EmployeeID, Employee.LastName, Bicycle.SaleState, Bicycle.ModelType, Bicycle.StoreID, Bicycle.OrderDate
FROM	Employee INNER JOIN Bicycle ON Employee.EmployeeID = Bicycle.EmployeeID
WHERE	Bicycle.SaleState = 'WI' AND 
		Bicycle.ModelType = 'Race' AND 
		(Bicycle.StoreID <3 Or Bicycle.StoreID Is Null) AND 
		Year(Bicycle.OrderDate) = 2001


/*3. List all of the (distinct) rear derailleurs installed on road bikes sold in Florida in 2002.*/
--5/5 no errors in execution and answers all business queries correctly, joins all correct and necessary tables
SELECT    DISTINCT Component.ComponentID, Manufacturer.ManufacturerName, Component.ProductNumber
FROM    Manufacturer INNER JOIN Component ON Manufacturer.ManufacturerID = Component.ManufacturerID
        INNER JOIN BikeParts ON Component.ComponentID = BikeParts.ComponentID
        INNER JOIN Bicycle ON Bicycle.SerialNumber = BikeParts.SerialNumber
WHERE    Component.Category = 'rear derailleur' AND
        Datepart(Year, Bicycle.OrderDate) = 2002 AND
        Bicycle.SaleState = 'FL' AND
        Bicycle.ModelType ='Road';


/*4.  Who bought the largest (frame size) full suspension mountain bike sold in Georgia in 2004?*/
--5/5 no errors in execution and answers all business queries correctly, properly nested query 
SELECT	Customer.CustomerID, Customer.LastName, Customer.FirstName, Bicycle.ModelType, Bicycle.SaleState, Bicycle.FrameSize, Bicycle.OrderDate
FROM	Customer INNER JOIN Bicycle ON Customer.CustomerID = Bicycle.CustomerID
WHERE	Bicycle.ModelType = 'Mountain full' AND 
		Bicycle.SaleState = 'GA' AND 
		Year(Bicycle.OrderDate) = 2004 AND
		Bicycle.FrameSize = (
		SELECT	Max(Bicycle.FrameSize)
		FROM	Customer INNER JOIN Bicycle ON Customer.CustomerID = Bicycle.CustomerID
		WHERE	Bicycle.ModelType ='Mountain full' AND 
				Bicycle.SaleState = 'GA' AND 
				Year(Bicycle.OrderDate) = 2004
		)

/*5. Which manufacturer gave us the largest discount on an order in 2003?*/
--5/5 no error in execution and answers all business queries correctly, distinct not necessary
SELECT	Distinct Manufacturer.ManufacturerID, Manufacturer.ManufacturerName
FROM	Manufacturer INNER JOIN PurchaseOrder ON Manufacturer.ManufacturerID = PurchaseOrder.ManufacturerID
WHERE	Year(PurchaseOrder.OrderDate) = 2003 AND
		PurchaseOrder.Discount = (
		SELECT	Max(PurchaseOrder.Discount)
		FROM	Manufacturer INNER JOIN PurchaseOrder ON Manufacturer.ManufacturerID = PurchaseOrder.ManufacturerID
		WHERE	Year(PurchaseOrder.OrderDate) = 2003
		)

/* 6. What is the most expensive road bike component we stock that has a quantity on hand greater than 200 units? */
--5/5 no error in execution and answers all business queries correctly, can be made simplier by using a self join rather than inner join
SELECT	Component.ComponentID, Manufacturer.ManufacturerName, Component.ProductNumber, Component.Road, Component.Category, Component.ListPrice, Component.QuantityOnHand
FROM	Manufacturer INNER JOIN Component ON Manufacturer.ManufacturerID = Component.ManufacturerID
WHERE	Component.Road = 'Road' AND 
		Component.QuantityOnHand > 200 AND
		Component.ListPrice = 
		(
			SELECT	Max(Component.ListPrice)
			FROM	Manufacturer INNER JOIN Component ON Manufacturer.ManufacturerID = Component.ManufacturerID
			WHERE	Component.Road = 'Road' AND 
					Component.QuantityOnHand > 200
		)
		


/* 7. Which inventory item represents the most money sitting on the shelf—based on estimated cost?*/
--4.9/5 free or errors but SUM is not necessary, by using Component.EstimatedCost in WHERE statement and using a nested query to then SELECT the MAX(EstimatedCost) from compomnents makes query simpler
SELECT	Component.ComponentID, Manufacturer.ManufacturerName, Component.ProductNumber, Component.Category, Component.Year, Sum([EstimatedCost]*[QuantityOnHand]) AS [Value]
FROM	Manufacturer INNER JOIN Component ON Manufacturer.ManufacturerID = Component.ManufacturerID
GROUP BY Component.ComponentID, Manufacturer.ManufacturerName, Component.ProductNumber, Component.Category, Component.Year
HAVING Sum([EstimatedCost]*[QuantityOnHand]) = 
		(
			SELECT	Top 1 Sum([EstimatedCost]*[QuantityOnHand])
			FROM	Manufacturer INNER JOIN Component ON Manufacturer.ManufacturerID = Component.ManufacturerID
			GROUP BY Component.ComponentID, Manufacturer.ManufacturerName, Component.ProductNumber, Component.Category, Component.Year
			ORDER BY Sum([EstimatedCost]*[QuantityOnHand]) DESC
		)

/*8. What is the greatest number of components ever installed in one day by one employee?*/
SELECT	Employee.EmployeeID, Employee.LastName, BikeParts.DateInstalled, Count(BikeParts.ComponentID) AS CountOfComponentID
FROM	Employee INNER JOIN BikeParts ON Employee.EmployeeID = BikeParts.EmployeeID
WHERE	BikeParts.DateInstalled is not null
GROUP BY Employee.EmployeeID, Employee.LastName, BikeParts.DateInstalled
HAVING	Count(BikeParts.ComponentID) = 
		(
			SELECT	Top 1 Count(BikeParts.ComponentID)
			FROM	Employee INNER JOIN BikeParts ON Employee.EmployeeID = BikeParts.EmployeeID
			WHERE	BikeParts.DateInstalled is not null
			GROUP BY Employee.EmployeeID, Employee.LastName, BikeParts.DateInstalled
			ORDER BY Count(BikeParts.ComponentID) DESC
		)

--5/5 - Querie would retrieve greatest number of components with no issue. The only difference would be that the first query used the MAX function to retrieve the maximum count of components.


/*9. What was the most popular letter style on race bikes in 2003?*/
SELECT	Bicycle.LetterStyleID, Count(Bicycle.SerialNumber) AS CountOfSerialNumber
FROM	Bicycle
WHERE	Year(Bicycle.OrderDate) = 2003 AND
		Bicycle.ModelType = 'race'
GROUP BY Bicycle.LetterStyleID
HAVING	Count(Bicycle.SerialNumber) = 
		(
			SELECT	Top 1 Count(Bicycle.SerialNumber)
			FROM	Bicycle
			WHERE	Year(Bicycle.OrderDate) = 2003 AND
					Bicycle.ModelType = 'race'
			GROUP BY Bicycle.LetterStyleID		
			ORDER BY Count(Bicycle.SerialNumber) DESC
		)
		
--2.5/5 - The first query retrieves all the letter styles on race bikes in 2003 that have the same count of serial numbers as the maximum count of serial numbers for any letter style.


/*10. Which customer spent the most money with us and how many bicycles did that person buy in 2002?*/
SELECT	Customer.CustomerID, Customer.LastName, Customer.FirstName, Count(Bicycle.SerialNumber) AS [Number of Bikes], Sum(Bicycle.SalePrice) AS [Amount Spent]
FROM	Customer INNER JOIN Bicycle ON Customer.CustomerID = Bicycle.CustomerID
WHERE	Year(Bicycle.OrderDate) = 2002
GROUP BY Customer.CustomerID, Customer.LastName, Customer.FirstName
HAVING	Sum(Bicycle.SalePrice) = 
		(
			SELECT	Top 1 Sum(Bicycle.SalePrice)
			FROM	Customer INNER JOIN Bicycle ON Customer.CustomerID = Bicycle.CustomerID
			WHERE	Year(Bicycle.OrderDate) = 2002
			GROUP BY Customer.CustomerID, Customer.LastName, Customer.FirstName
			ORDER BY Sum(Bicycle.SalePrice) DESC
		)

-- 5/5 - Query executes correctly and reaches solution efficiently.

/*11. Have the sales of mountain bikes (full suspension or hard tail) increased or decreased from 2000 to 2004 (by count not by value)?*/
SELECT	Year([OrderDate]) AS SaleYear, Count(Bicycle.SerialNumber) AS CountOfSerialNumber
FROM	Bicycle
WHERE	Bicycle.ModelType Like 'mountain%'
GROUP BY Year([OrderDate])
HAVING	Year([OrderDate]) Between 2000 And 2004
ORDER BY Year([OrderDate])

-- 5/5 - Query executes correctly and reaches solution efficiently.

/*12. Which component did the company spend the most money on in 2003?*/
SELECT TOP 1 Component.COMPONENTID, Manufacturer.ManufacturerName, Component.ProductNumber,
Component.Category, Sum([PricePaid]*[Quantity]) AS [Value]
FROM COMPONENT INNER JOIN MANUFACTURER ON Manufacturer.ManufacturerID = Component.ManufacturerID
INNER JOIN PURCHASEITEM ON Component.ComponentID = PurchaseItem.ComponentID
INNER JOIN PurchaseOrder ON PurchaseOrder.PurchaseID = PurchaseItem.PurchaseID
WHERE YEAR(ORDERDATE) = 2003
GROUP BY Component.COMPONENTID, Manufacturer.ManufacturerName, Component.ProductNumber,
Component.Category
ORDER BY [VALUE] DESC;

-- 5/5 - Query executes correctly and reaches solution efficiently.
		
/*13. Which employee painted the most red race bikes in May 2003?*/
SELECT	Employee.EmployeeID, Employee.LastName, Count(Bicycle.SerialNumber) AS [Number Painted]
FROM	Employee INNER JOIN (Paint INNER JOIN Bicycle ON Paint.PaintID = Bicycle.PaintID) ON Employee.EmployeeID = Bicycle.Painter
WHERE	Year(Bicycle.StartDate) = 2003 And 
		Month(Bicycle.StartDate) = 5 AND
		Paint.ColorList Like '%Red%' AND
		Bicycle.ModelType = 'Race'
GROUP BY Employee.EmployeeID, Employee.LastName
HAVING	Count(Bicycle.SerialNumber) = 
		(
			SELECT	Top 1 Count(Bicycle.SerialNumber)
			FROM	Employee INNER JOIN (Paint INNER JOIN Bicycle ON Paint.PaintID = Bicycle.PaintID) ON Employee.EmployeeID = Bicycle.Painter
			WHERE	Year(Bicycle.StartDate) = 2003 And 
					Month(Bicycle.StartDate) = 5 AND
					Paint.ColorList Like '%Red%' AND
					Bicycle.ModelType = 'Race'
			GROUP BY Employee.EmployeeID, Employee.LastName
			ORDER BY Count(Bicycle.SerialNumber) DESC
		)

-- 1/5 - Query executes and has correct columns, but incorrect information is retreived.

/*14. Which California bike shop helped sell the most bikes (by value) in 2003?*/
SELECT	RetailStore.StoreID, RetailStore.StoreName, City.City, Sum(Bicycle.SalePrice) AS SumOfSalePrice
FROM	(City RIGHT JOIN RetailStore ON City.CityID = RetailStore.CityID) INNER JOIN Bicycle ON RetailStore.StoreID = Bicycle.StoreID
WHERE	City.State = 'CA' AND 
		Year(Bicycle.OrderDate) = 2003
GROUP BY RetailStore.StoreID, RetailStore.StoreName, City.City
HAVING	Sum(Bicycle.SalePrice) = 
		(
			SELECT	Top 1 Sum(Bicycle.SalePrice)
			FROM	(City RIGHT JOIN RetailStore ON City.CityID = RetailStore.CityID) INNER JOIN Bicycle ON RetailStore.StoreID = Bicycle.StoreID
			WHERE	City.State = 'CA' AND 
					Year(Bicycle.OrderDate) = 2003		
			GROUP BY RetailStore.StoreID, RetailStore.StoreName, City.City
			ORDER BY Sum(Bicycle.SalePrice) DESC
		)

/*15. What is the total weight of the components on bicycle 11356?*/
SELECT	Sum([Quantity]*[Weight]) AS TotalWeight
FROM	Component INNER JOIN BikeParts ON Component.ComponentID = BikeParts.ComponentID
WHERE	BikeParts.SerialNumber= 11356

/*16.  What is the total list price of all items in the 2002 Campy Record groupo?*/
SELECT	Groupo.GroupName, Sum(Component.ListPrice) AS SumOfListPrice
FROM	Component INNER JOIN (Groupo INNER JOIN GroupComponents ON Groupo.ComponentGroupID = GroupComponents.GroupID) ON Component.ComponentID = GroupComponents.ComponentID
GROUP BY Groupo.GroupName
HAVING	Groupo.GroupName = 'Campy Record 2002'

/*17. In 2003, were more race bikes built from carbon or titanium (based on the down tube)?*/
SELECT	TubeMaterial.Material, Count(Bicycle.SerialNumber) AS CountOfSerialNumber
FROM	(Bicycle INNER JOIN BikeTubes ON Bicycle.SerialNumber = BikeTubes.SerialNumber) INNER JOIN TubeMaterial ON BikeTubes.TubeID = TubeMaterial.TubeID
WHERE	Bicycle.ModelType = 'Race' AND 
		Year(Bicycle.OrderDate) = 2003 AND 
		BikeTubes.TubeName =  'Down'
GROUP BY TubeMaterial.Material
HAVING	TubeMaterial.Material Like 'Carbon%' Or 
		TubeMaterial.Material Like 'Titanium%'

/*18.  What is the average price paid for the 2001 Shimano XTR rear derailleurs?*/
SELECT	Convert(Money, Avg(PurchaseItem.PricePaid), 1) AS AvgOfPricePaid
FROM	Manufacturer INNER JOIN (Component INNER JOIN PurchaseItem ON Component.ComponentID = PurchaseItem.ComponentID) ON Manufacturer.ManufacturerID = Component.ManufacturerID
WHERE	Manufacturer.ManufacturerName = 'Shimano (USA)' AND 
		Component.ProductNumber Like '%XTR%' AND 
		Component.Category = 'rear derailleur' AND 
		Component.Year = 2001

5/5 - There were no syntactical errors and retrives the average price paid for a rear derailleur component produced with the product number containing "XTR".

/*19. What is the average top tube length for a 54 cm (frame size) road bike built in 1999?*/
SELECT	Avg(Bicycle.TopTube) AS AvgOfTopTube
FROM	Bicycle
WHERE	Year(Bicycle.OrderDate) = 1999 AND
		Bicycle.ModelType = 'Road' AND 
		Bicycle.FrameSize = 54
		
5/5 - The qwuery filters the 'Bicycle' table based on given criteria then calculates the avg top tube length for all bicycles that match the critera.

/*20. On average, which costs (list price) more: road tires or mountain bike tires?*/
SELECT	Component.Road, Avg(Component.ListPrice) AS AvgOfListPrice
FROM	Component
WHERE	Component.Category Like 'tire%'
GROUP BY Component.Road;

2/5 - The query does not directly compare the average list price of road and mountain bike tires. It groups the results by 'Road' and provides the averahe list price for each group seperately.

select distinct modeltype from bicycle

/*21 In May 2003, which employees sold road bikes that they also painted?*/
SELECT	DISTINCT Employee.EmployeeID, Employee.LastName
FROM	Employee INNER JOIN Bicycle ON Employee.EmployeeID = Bicycle.EmployeeID
WHERE	Employee.EmployeeID = Painter AND
		Bicycle.ModelType = 'Road' AND
		Year(Bicycle.OrderDate) = 2003 AND
		Month(Bicycle.OrderDate) = 5

3/5 - This query seems to have a syntax error. The variable 'Painter' is not defined, and it should be enclosed in quotation marks to indicate that it is a string.
		
/*22. In 2002, was the Old English letter style more popular with some paint jobs?*/
--4/5 This query runs and does not have any syntax errors. It should be letter stylle "Old English" not just "English."
SELECT	Bicycle.PaintID, Paint.ColorName, Count(Bicycle.SerialNumber) AS [Number of Bikes Painted]
FROM	Paint INNER JOIN Bicycle ON Paint.PaintID = Bicycle.PaintID
WHERE	Bicycle.LetterStyleID = 'English' AND 
		Year(Bicycle.OrderDate) = 2002
GROUP BY Bicycle.PaintID, Paint.ColorName
ORDER BY Count(Bicycle.SerialNumber) DESC;


SELECT DISTINCT P.PAINTID, P.COLORNAME, COUNT (B.SERIALNUMBER) AS'NUMBEROFBIKESPAINTED'
FROM BIKE..PAINT P INNER JOIN BIKE.. BICYCLE B ON B.PAINTID= P.PAINTID INNERJOIN BIKE..LETTERSTYLE L ON L.LETTERSTYLE= B.LETTERSTYLEID
WHERE YEAR (B.ORDERDATE)=2002 AND L.DESCRIPTION LIKE 'OLD ENGLISH'
GROUP BY P.PaintID, P.COLORNAME



/*23. Which race bikes in 2003 sold for more than the average price of race bikes in 2002?*/
--5/5 The query rus and does not have any syntax errors. It returns the desired answer.
SELECT	Bicycle.SerialNumber, Bicycle.ModelType, Bicycle.OrderDate, Bicycle.SalePrice
FROM	Bicycle
WHERE	Bicycle.ModelType ='race' AND 
		Datepart(Year, Bicycle.OrderDate) =2003 AND 
		Bicycle.SalePrice >
		(SELECT Avg(Bicycle.SalePrice) AS AvgOfSalePrice
		FROM	Bicycle
		WHERE	Bicycle.ModelType = 'race' AND
				Datepart(Year, Bicycle.OrderDate) = 2002)
ORDER BY Bicycle.SalePrice DESC

/*24. Which component that had no sales (installations) in 2004 has the highest inventory value (cost basis)?*/
--5/5 : Your query correct, Your query create a view and select data that had no sales (installations) in 2004 has the highest inventory value (cost basis).

CREATE	VIEW V24 AS
SELECT	DISTINCT BikeParts.ComponentID
FROM	BikeParts
WHERE	Year(BikeParts.DateInstalled) = 2004

SELECT	Manufacturer.ManufacturerName, Component.ProductNumber, Component.Category, 
		[EstimatedCost]*[QuantityOnHand] AS [Value], V.ComponentID
FROM	Manufacturer INNER JOIN (Component LEFT JOIN V24 V ON Component.ComponentID = V.ComponentID) 
		ON Manufacturer.ManufacturerID = Component.ManufacturerID
WHERE	V.ComponentID Is Null
ORDER BY [EstimatedCost]*[QuantityOnHand] DESC;



/*25. Create a vendor contacts list of all manufacturers and retail stores in California.
Include only the columns for VendorName and Phone. The retail stores should only
include stores that participated in the sale of at least one bicycle in 2004*/
--5/5 The query is correct and executes without issue, it successfully creates a vendor list following the criteria. 
SELECT	DISTINCT  RetailStore.StoreName AS [Store Name Or Manufacturer Name], RetailStore.Phone
FROM	City RIGHT JOIN (RetailStore INNER JOIN Bicycle ON RetailStore.StoreID = Bicycle.StoreID) ON City.CityID = RetailStore.CityID
WHERE	City.State = 'ca' AND 
		Year(Bicycle.OrderDate) = 2004

UNION 

SELECT	Manufacturer.ManufacturerName AS [Store Name or Manufacturer Name], Manufacturer.Phone
FROM	Manufacturer


/*26. List all of the employees who report to Venetiaan.*/
--5/5 This query runs and does not have any syntax errors. However, it returns 2 columns with the same name "LastName", this could cause confusion.
SELECT	Employee_1.LastName, Employee.EmployeeID, Employee.LastName, Employee.FirstName, Employee.Title
FROM	Employee AS Employee_1 INNER JOIN Employee ON Employee_1.EmployeeID = Employee.CurrentManager
WHERE	Employee_1.LastName='Venetiaan'



/*27. List the components where the company purchased at least 25 percent more units than it used through June 30, 2000. */
--5/5:  The query is correct and effectively answers the given business question listing the compomnents where the company purchased at least 25 percent more units than it used through June 30, 2000 .
CREATE	VIEW V27A AS
SELECT	PurchaseItem.ComponentID, Sum(PurchaseItem.QuantityReceived) AS TotalReceived
FROM	PurchaseOrder INNER JOIN PurchaseItem ON PurchaseOrder.PurchaseID = PurchaseItem.PurchaseID
WHERE	PurchaseOrder.ReceiveDate < '7/1/2000'
GROUP BY PurchaseItem.ComponentID

CREATE	VIEW V27B AS
SELECT	BikeParts.ComponentID, Sum(BikeParts.Quantity) AS TotalUsed
FROM	BikeParts
WHERE	BikeParts.DateInstalled < '7/1/2000'
GROUP BY BikeParts.ComponentID

SELECT	Component.ComponentID, Manufacturer.ManufacturerName, Component.ProductNumber, Component.Category, 
		V1.TotalReceived, V2.TotalUsed, [TotalReceived]-[TotalUsed] AS NetGain, 
		([TotalReceived]-[TotalUsed])/[TotalUsed] AS NetPct, Component.ListPrice
FROM	Manufacturer INNER JOIN ((V27A V1 INNER JOIN Component ON V1.ComponentID = Component.ComponentID) INNER JOIN V27B V2 ON Component.ComponentID = V2.ComponentID) ON Manufacturer.ManufacturerID = Component.ManufacturerID
WHERE	(([TotalReceived]-[TotalUsed])*1.0/[TotalUsed]*1.0)>0.25
ORDER BY ([TotalReceived]-[TotalUsed])/[TotalUsed] DESC;

/*28. In which years did the average build time for the year exceed the overall average build time for all years? 
	  The build time is the difference between order date and ship date. */
--5/5: This query runs and executes correctly returning a table with years that exceed the overall average build time for all years.

SELECT DATEPART(YEAR, OrderDate) AS [Year], Avg(1.0* DATEDIFF(DAY, OrderDate, ShipDate)) AS BuildTime
FROM	Bicycle
GROUP BY DATEPART(YEAR, OrderDate)
HAVING	Avg(1.0* DATEDIFF(DAY, OrderDate, ShipDate))>
	(SELECT Avg(1.0* DATEDIFF(DAY, OrderDate, ShipDate))
	FROM Bicycle)
ORDER BY Avg(1.0* DATEDIFF(DAY, OrderDate, ShipDate)) DESC;